<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>quasi one</title>
  <!-- Additional meta tags, stylesheets, or scripts -->
  <script src="./calculations.js"></script>
  <link rel="stylesheet" type="text/css" href="./style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.0/dist/chartjs-plugin-annotation.min.js"></script>
 <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
 <script defer src="https://pyscript.net/latest/pyscript.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
   <py-config>
    packages = ["numpy"] 
  </py-config>
  <py-script>
    import argparse
    import sys
    import numpy as np
    import warnings

    #mimic argparse
    class Args:
        def __init__(self, AR=1.0, Ad=0.0, cd=0.0, cf=0.0, Af=0.0, M1=0.0, xi=0.5, nu=0.0,
                    qr=0.0, k=1.4, twr=1.0, isentropic=False, b1=1.0, b2=1.0, a1=1.0, a2=1.0, debug=False):
            self.AR = AR
            self.Ad = Ad
            self.cd = cd
            self.cf = cf
            self.Af = Af
            self.M1 = M1
            self.xi = xi
            self.nu = nu
            self.qr = qr
            self.k = k
            self.twr = twr
            self.isentropic = isentropic
            self.b1 = b1
            self.b2 = b2
            self.a1 = a1
            self.a2 = a2
            self.debug = debug
    TR = 0
    G = 0
    f1 = 0
    Lambda = 0
    b = 0
    c = 0
    det = 0
    def main():
      from js import P, T , M1 , A1 , gamma , alpha1 , beta1 , w , Fx , m2 , A2 , Q , xi , nu , f , alpha2 , beta2 , N
      ver = str('v1.7')
      date = str('10/01/22')

      args = Args(AR=A2/A1, M1=M1, xi = xi, nu = nu, k = gamma, b1 = beta1, b2 = beta2, a1 = alpha1, a2 = alpha2 )

      if( args.isentropic ):
          args = isentropic(args)
          args = coefsBiquadratic(args)

      else:
          args = coefsBiquadratic(args)
          args = solveBiquadratic(args)

      args = postProcess(args)

      printOutput(args) #-> updateResults
      
      return()
    def coefsBiquadratic(args):
      '''
      calculate the 2nd and zeroth order coefficients of the bi-quadratic polynomial
      '''
      M1 = args.M1
      k  = args.k
      AR = args.AR
      Ad = args.Ad
      cd = args.cd
      cf = args.cf
      Af = args.Af
      nu = args.nu
      qr = args.qr
      xi = args.xi
      beta1 = args.b1
      beta2 = args.b2
      alpha1 = args.a1
      alpha2 = args.a2

      TR = np.float64(bool(k-1))*(1 + args.qr) + np.float64(not bool(k-1))*1

      G = (k-1)/2

      f1 = 1 + G * M1*M1

      try:
          Lambda = np.complex128(\
                      ((1 + beta1*k*(1-cf/4*Af - cd/2*Ad)*M1**2 + (1-xi+nu*(f1**(k/(k-1))-1))*(AR-1) ) \
                      /(alpha1/alpha2*M1*np.sqrt(f1*TR))) \
                      )
          Lambda *= Lambda
      except:
          Lambda = np.complex128(\
                      ((1 + beta1*k*(1-cf/4*Af - cd/2*Ad)*M1**2 + (1-xi+nu*(np.exp(-M1**2)-1))*(AR-1) ) \
                      /(alpha1/alpha2*M1*np.sqrt(f1*TR))) \
                      )
          Lambda *= Lambda


      b = (Lambda - 2*k*beta2*(1+xi*(1/AR-1))*(1+cf/4*Af/AR)) \
              /(Lambda * G  -(k*beta2*(1+cf/4*Af/AR))**2)
      c = -(1+xi*(1/AR-1))**2 \
              /(Lambda * G  -(k*beta2*(1+cf/4*Af/AR))**2)

      det = (b/2)*(b/2)-c

      args.Lambda = np.real(Lambda)
      args.b = np.real(b)
      args.c = np.real(c)
      args.det = np.real(det)

      return(args)

    def solveBiquadratic(args):
        '''
        Solution to mass, momentum, and energy balance equations.
        Mass balance is simple inlet nad outlet balance
        Momentum balance as 1 friction force and 1 drag force
        Energy balance has 1 heat addition term
        Gravity and other sources of Potential Energy have been ignored.
        Uses calorically perfect ideal gas assumption.
        '''

        b = args.b
        c = args.c
        det = args.det

        roots = np.array([-b/2+np.sqrt(det),-b/2-np.sqrt(det)],dtype=np.complex128)

        # reject non-physical roots and replace with nans
        args.M2 = np.sqrt(rejectNonphysicalRoots(roots,keepNans=True))

        return(args)

    def postProcess(args):
        '''
        standard post-processing routine for all solutions
        '''
        M2 = args.M2

        M1 = args.M1
        k  = args.k
        AR = args.AR
        xi = args.xi
        nu = args.nu
        qr = args.qr
        cf = args.cf
        Af = args.Af
        cd = args.cd
        Ad = args.Ad
        TwTo1 = args.twr
        alpha1 = args.a1
        alpha2 = args.a2
        beta1 = args.b1
        beta2 = args.b2

        G = (k-1)/2

        f1 = 1 + G * M1*M1
        f2 = 1 + G * M2*M2

        TR = np.float64(bool(k-1))*(1 + qr) + np.float64(not bool(k-1))*1

        try:
            PR = alpha1/alpha2 * np.sqrt(TR) * M1/M2 * 1./AR * (f1/f2)**(-(k+1)/(2*(k-1)))

            dsR  = k/(k-1) *np.log(TR) - np.log(PR)

            P2P1  = alpha1/alpha2 * np.sqrt(TR) * M1/M2 * 1./AR * np.sqrt(f1/f2)

            P3P1 = ((1 - xi - nu) + xi * P2P1 + nu * f1**(k/(k-1)))*np.ones_like(M2)

        except:
            PR = alpha1/alpha2*np.sqrt(TR) * M1/M2 * 1/AR * np.exp(0.5*(M2*M2-M1*M1))

            dsR = - np.log(PR)

            P2P1  = alpha1/alpha2*np.sqrt(TR) * M1/M2 * 1./AR * np.sqrt(f1/f2)

            P3P1 = ((1-xi-nu) + xi*P2P1 + nu * np.exp(M1*M1/2))*np.ones_like(M2)

        T2T1  = TR*(f1/f2)
        p2p1  = P2P1/T2T1
        v2v1  = 1/p2p1
        M2M1  = M2/M1
        V2V1  = M2M1 *np.sqrt(T2T1)

        args.V2V1  = V2V1
        args.v2v1  = v2v1
        args.p2p1  = p2p1
        args.PR    = PR
        args.TR    = TR*np.ones_like(M2)
        args.P2P1  = P2P1
        args.T2T1  = TR * (f1/f2)
        args.dsR   = dsR
        args.dsRKE = dsR/(k/2*M1*M1)
        args.dsRKE2= dsR/(k/2*M2*M2)
        args.P3P1  = P3P1
        args.wpv    = -np.log(P2P1*V2V1*AR)
        args.wrev    = -np.log(V2V1*AR)

        try:
            args.CP    = (P2P1 - 1)/(args.f1**(k/(k-1))-1)
            args.wloss = (1 - PR)/(1 - args.f1**(-k/(k-1)))
            args.zloss = f1**(k/(k-1))*(1 - PR)/(k/2*M1**2)
            args.Iq    = k/4*(M2**2+M1**2)*np.log(TR) \
                            + k/(k-1)*(np.log(TR) - 1/TwTo1*(TR-1))
            args.Theta = k/(k-1)* 1/TwTo1*(TR-1)*np.ones_like(M2)

        except:
            args.CP    = (P2P1-1)/np.exp(-M1**2/2)
            args.wloss = (1 - PR)/(1 - np.exp(-M1**2/2))
            args.zloss = np.exp(M1**2/2)*(1 - PR)/(k/2*M1*M1)
            args.Theta = k/(k-1+1e-16)* 1/TwTo1*(TR-1)*np.ones_like(M2)


        def get_approx(M2,M1,TR):
            trapezoid = (M1**2 + M2**2/TR)/2*(TR-1)
            midpoint  = (M1 + M2)**2/(TR+1)/2*(TR-1)
            #return( 2/3*midpoint + 1/3*trapezoid)
            #return(trapezoid)
            return(midpoint)


        args.ek    = k/(k-1+1e-16)*np.log(f2/f1) + k/2*get_approx(M2,M1,TR)
        args.Iq    = k/2*get_approx(M2,M1,TR) \
                        + k/(k-1+1e-16)*(np.log(TR) - 1/TwTo1*(TR-1))

        args.we    = args.wpv - args.ek
        args.I     = args.we - args.wrev + args.Iq
        args.f1    = f1
        args.f2    = f2
        args.CPinc = (P2P1 - 1)/(k/2*M1*M1)

        return(args)
    def rejectNonphysicalRoots(roots,keepNans=False):

      # set any roots with negative real part to nan
      roots[np.real(roots)<0] = np.nan

      # set any roots with non-zero imaginary part to nan 
      roots[~np.isclose(np.imag(roots),0,atol=1e-6)] = np.nan


      # sort values from lowest to highest
      roots.sort()

      # remove any nans from roots, cast as real, and return
      if( keepNans):
          return(np.real(roots))
      else:
          return(np.real(roots[~np.isnan(roots)]))
    def printOutput(args):
      '''
      take previous calculations and output them to screen for user
      '''

      # if not isentropic then make these values an array with 2 elements of the same value
      # this is done for later printing
      # does not affect the values if they are already an array with 2 elements
      args.Lambda = args.Lambda * np.ones((2,),dtype=np.float64)
      args.b = args.b * np.ones((2,),dtype=np.float64)
      args.c = args.c * np.ones((2,),dtype=np.float64)
      args.det = args.det * np.ones((2,),dtype=np.float64)

      print("{0:20s} {1: >13s} {2: >13s}".format('Outputs','Root 1','Root 2'))
      print("-"*48)
      if( args.isentropic ):
          print("{0:20s} {1: .6e} {2: .6e}".format("xi (ds=0)",args.xi[0],args.xi[1]))

      print("{0:20s} {1: .6e} {2: .6e}".format("M2",args.M2[0],args.M2[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("M2/M1",args.M2[0]/args.M1,args.M2[1]/args.M1))
      print("{0:20s} {1: .6e} {2: .6e}".format("ds/R",args.dsR[0],args.dsR[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("(ds/R)/(k/2*M1**2)",args.dsRKE[0],args.dsRKE[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("(Po1-Po2)/(Po1-P1)",args.wloss[0],args.wloss[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("Po2/Po1",args.PR[0],args.PR[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("P2/P1",args.P2P1[0],args.P2P1[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("(P2-P1)/(Po1-P1)",args.CP[0],args.CP[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("To2/To1",args.TR[0],args.TR[1]))
      print("{0:20s} {1: .6e} {2: .6e}".format("T2/T1",args.T2T1[0],args.T2T1[1]))
      if( args.debug ):
          print("\n\n",end='')
          print("{0:20s} {1: >13s} {2: >13s}".format('Debug','Root 1','Root 2'))
          print("-"*48)
          if( args.isentropic):
              print("{0:20s} {1: 13d} {2: 13d}".format("iter",args.iter[0],args.iter[1]))
              print("{0:20s} {1: 13d} {2: 13d}".format("nfev",args.nfev[0],args.nfev[1]))
              print("{0:20s} {1: .6e} {2: .6e}".format("M2 (apprx)",args.initialM2[0],args.initialM2[1]))
              print("{0:20s} {1: .6e} {2: .6e}".format("M2 (k->1 )",args.infinatomicM2[0],args.infinatomicM2[1]))
              print("{0:20s} {1: .6e} {2: .6e}".format("M2 (k~7/5)",args.diatomicM2[0],args.diatomicM2[1]))
              print("{0:20s} {1: .6e} {2: .6e}".format("M2 (k=5/3)",args.monatomicM2[0],args.monatomicM2[1]))

          print("{0:20s} {1: .6e} {2: .6e}".format("V2V1",args.V2V1[0],args.V2V1[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("v2v1",args.v2v1[0],args.v2v1[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("p2p1",args.p2p1[0],args.p2p1[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("wpv",args.wpv[0],args.wpv[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("ek",args.ek[0],args.ek[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("Iq",args.Iq[0],args.Iq[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("we",args.we[0],args.we[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("wrev",args.wrev[0],args.wrev[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("I",args.I[0],args.I[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("Theta",args.Theta[0],args.Theta[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("I+Theta",args.I[0]+args.Theta[0],args.I[1]+args.Theta[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("dsR/(k/2*M2**2)",args.dsRKE2[0],args.dsRKE2[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("(Po1-Po2)/q",args.zloss[0],args.zloss[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("(P2-P1)/q",args.CPinc[0],args.CPinc[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("P3/P1",args.P3P1[0],args.P3P1[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("P3/P2",args.P3P1[0]/args.P2P1[0],args.P3P1[1]/args.P2P1[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("P3/Po1",args.P3P1[0]/args.f1,args.P3P1[1]/args.f1))
          print("{0:20s} {1: .6e} {2: .6e}".format("Lambda",args.Lambda[0],args.Lambda[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("b",args.b[0],args.b[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("c",args.c[0],args.c[1]))
          print("{0:20s} {1: .6e} {2: .6e}".format("determinant",args.det[0],args.det[1]))

      return()
  </py-script>
</head>
<body>
    <div class="title">
        <h3>Steady, quasi-one-dimensional, internal compressible flow with area change, heat addition and friction</h3>
        <p class="credits">Thesis by Andrew Oliva and Scott Morris <a href="https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/steady-quasionedimensional-internal-compressible-flow-with-area-change-heat-addition-and-friction/941B60C217C6096C6980DFDD4B5F9E34" target="_blank" rel="noopener noreferrer">Here</a></p>
    </div>
    <div class="content">
    <div class="input-container">
        <form class="inputFields">
            <div class="InputIn">
                <h4 class="InputHeaders">Inlet Conditions</h4>
                <div class="label-input-row">
                <label for="P">P=</label>
                <input type="text" id="P">
                </div>

                <div class="label-input-row">
                <label for="T">T=</label>
                <input type="text" id="T">
                </div>

                <div class="label-input-row">
                <label for="M1">M<sub>1</sub>=</label>
                <input type="text" id="M1">
                </div>

                <div class="label-input-row">
                <label for="A1">A<sub>1</sub>=</label>
                <input type="text" id="A1" oninput="imageGUI()">
                </div>

                <div class="label-input-row">
                <label for="gamma">&gamma;=</label>
                <input type="text" id="gamma">
                </div>

                <div class="label-input-row">
                <label for="alpha1">&alpha;<sub>1</sub>=</label>
                <input type="text" id="alpha1">
                </div>

                <div class="label-input-row">
                <label for="beta1">&beta;<sub>1</sub>=</label>
                <input type="text" id="beta1">
                </div>
            </div>
            <div class="Gui">
              <canvas id="myChart"></canvas>
          </div>
            <div class="InputOut">
                <h4 class="InputHeaders">Outlet Conditions</h4>
                <div class="label-input-row">
                <label for="w">w=</label>
                <input type="text" id="w">
                </div>

                <div class="label-input-row">
                <label for="Fx">F<sub>x</sub>=</label>
                <input type="text" id="Fx">
                </div>

                <div class="label-input-row">
                <label for="m2">m<sub>2</sub>=</label>
                <input type="text" id="m2">
                </div>

                <div class="label-input-row">
                <label for="Q">Q=</label>
                <input type="text" id="Q">
                </div>

                <div class="label-input-row">
                <label for="A2">A<sub>2</sub>=</label>
                <input type="text" id="A2" oninput="imageGUI()">
                </div>

                <div class="label-input-row">
                <label for="xi">&xi;=</label>
                <input type="text" id="xi">
                </div>

                <div class="label-input-row">
                <label for="nu">&nu;=</label>
                <input type="text" id="nu">
                </div>

                <div class="label-input-row">
                <label for="f">f=</label>
                <input type="text" id="f">
                </div>

                <div class="label-input-row">
                <label for="alpha2">&alpha;<sub>2</sub>=</label>
                <input type="text" id="alpha2">
                </div>

                <div class="label-input-row">
                <label for="beta2">&beta;<sub>2</sub>=</label>
                <input type="text" id="beta2">
                </div>

                <div class="label-input-row">
                <label for="subelements">N=</label>
                <input type="text" id="subelements" min="1" step="1" value="1">
                </div>
            </div>
        </form>
        <div class="exampleFlows">
            <h4>Example Flows</h4>
            <select class="selectFlow" onchange="exampleFlow()">
              <option>Isentropic flow with area change</option>
              <option>Flow across a normal shock</option>
              <option>Fanno flow</option>
              <option>Rayleigh flow</option>
              <option>Sudden expansion</option>
              <option>Sudden Contraction</option>
              <option>Two-stream mixing layer</option>
              <option>Simultaneous friction and heat transfer</option>
              <option>Simultaneous area change and friction</option>
            </select>
        </div>
    </div>
    <div class="output-container">
        <button id="calculate" onclick="calculateFlow(event)">Calculate</button>
        <div class="outputLabels">
            <h4>Results</h4>
            <div class="label-input-row">
              <label for="M2">M<sub>2</sub>=</label>
              <input type="text" id="M2">
            </div>

            <div class="label-input-row">
              <label for="PT2">P<sub>T<sub>2</sub></sub>=</label>
              <input type="text" id="PT2" name="Label">
            </div>

            <div class="label-input-row">
              <label for="P2">P<sub>2</sub>=</label>
              <input type="text" id="P2">
            </div>

            <div class="label-input-row">
              <label for="TT2">T<sub>T<sub>2</sub></sub>=</label>
              <input type="text" id="TT2">
            </div>

            <div class="label-input-row">
              <label for="T2">T<sub>2</sub>=</label>
              <input type="text" id="T2">
            </div>

            <div class="label-input-row">
              <label for="deltaS">&Delta;s=</label>
              <input type="text" id="deltaS">
            </div>
        </div>
        <canvas id="outputChart"></canvas>
    </div>
</div>
</body>

</html>